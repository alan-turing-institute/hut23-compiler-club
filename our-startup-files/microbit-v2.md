<div id="content" class="content">

# Our BBC micro:bit v2 linker script

<div id="outline-container-orgc42d0e1" class="outline-2">

## How to create the linker script

<div id="text-orgc42d0e1" class="outline-text-2">

This file explains and is also the source of the linker script we have
developed for the micro:bit version 2, at least as far as we have
developed it, which is currently not very far.

To extract (or “tangle,” in literate-programming parlance) the script
itself, run `make` in this directory. (You will need emacs to be
installed.)

</div>

</div>

<div id="outline-container-org255c2a3" class="outline-2">

## Overview

<div id="text-org255c2a3" class="outline-text-2">

The input to the linker (eg, GNU `ld`) is a set of files, known as
*object files*, containing code (in binary format) and data. The job of
the linker is to combine all the code and data in the input files into a
single output file, also known as an object file, that can be loaded
into a particular region of memory (or, in our case, flashed onto the
micro:bit).

However, when input object files are generated, for example by a C
compiler or an assembler, their final location in memory is not known.
Thus the files contain, not hard-coded memory locations, but *symbols*:
stand-ins for the final location of code or data. Each symbol is defined
in one of the input files to point to a particular part of the data, or
code, in that input file. The linker must decide what final location
each symbol refers to and arrange for all the references to that symbol,
in whatever file the reference occurs, to refer to that location.

The linker script is a configuration file read by the linker (use the
option “​`-T microbit-v2.ld`​”). The purpose of the linker script is:

1.  To describe the memory layout of the micro:bit;
2.  To arrange for the various “sections” of code and data to end up in
    the correct places in memory in the output object file.
3.  To name particular locations in memory that can only be decided at
    link time but which are referenced by the code.

Here is the overall structure of our script:

<div class="org-src-container">

``` src
/* 
BBC micro:bit v2 linker script
Written by the Hut23 Compiler Club
Do not edit this file directly; instead edit the source ".org" file 
*/

MEMORY {
  FLASH    (rx) : ORIGIN = 0x00000000, LENGTH = 512K  
  RAM      (wx) : ORIGIN = 0x20000000, LENGTH = 128K
  CODE_RAM (wx) : ORIGIN = 0x00800000, LENGTH = 128K 
}
SECTIONS {
  .text : {
    KEEP(*(.vectors))
    *(.text*)
    *(.rodata*)
  } >FLASH
  .data : ALIGN(4) {
    __data_start = .;
    *(.data)
    *(.data.*)
  } >RAM AT >FLASH
  __data_end = __data_start + SIZEOF(.data);  
  .bss : ALIGN(4) {
    __bss_start = .;
    *(.bss)
    *(.bss.*);
    . = ALIGN(4);
  } >RAM
  __bss_end = __bss_start + SIZEOF(.bss);
}
```

</div>

Each part is expanded below.

</div>

</div>

<div id="outline-container-orgf02ac39" class="outline-2">

## Explanation of each part

<div id="text-orgf02ac39" class="outline-text-2">

</div>

<div id="outline-container-orgadbd6d1" class="outline-3">

### 1. Memory layout

<div id="text-orgadbd6d1" class="outline-text-3">

The Cortex M4 is a 32-bit CPU, meaning that it can in principle address
\\2^{32}\\ bytes—or 4 GiB—of memory. However, the nRF52833 physically
has only 512 kiB of flash memory and 128 kiB of RAM (see section 4.2.3,
figure 3, of the nRF52833 product specification). The mapping of that
physical memory into the 4 GiB of “virtual” memory space is described by
the first part of the linker script.

<div class="org-src-container">

<span class="listing-number">Listing 1: </span>Memory layout of the
Nordic nRF528333

``` src
MEMORY {
  FLASH    (rx) : ORIGIN = 0x00000000, LENGTH = 512K  
  RAM      (wx) : ORIGIN = 0x20000000, LENGTH = 128K
  CODE_RAM (wx) : ORIGIN = 0x00800000, LENGTH = 128K 
}
```

</div>

(By the way, every linker file I've seen writes the attributes of the
RAM section as `rwx` rather than (as here) just `wx`. However, the GNU
`ld` manual (section 3.8) clearly says that the attribute `w` means read
*and* write.)

On this device the 128 kiB of physical RAM is mapped *both* to the
normal location (labelled as `RAM`) and *also* to an area of memory just
above the flash memory. This `CODE_RAM` is the same physical RAM, just
accessible from two different places in “memory.” The reason seems to be
that the CPU accesses this memory on a different bus and that this can
be faster if one is executing code. However, the rest of this linker
script ignores the code RAM.

There are other bits of memory—for example, the memory-mapped peripheral
registers, and some non-volatile configuration memory regions—but I am
unsure whether we should write that down here or not. That does not seem
to be the done thing but I am not entirely sure why not.

</div>

</div>

<div id="outline-container-orge91ef87" class="outline-3">

### 2. Input and output sections

<div id="text-orge91ef87" class="outline-text-3">

The content of the linker’s input files and output file are assigned to
regions called “sections.” One job of the linker is to map the sections
in the input files to the sections in the output file and to write in
the output file where the output sections are to end up in memory.

There are four conventional input sections produced, for example, by the
C compiler, which will be the input sections to the linker. (There may
be others but these seem to be the critical ones.) They are:

`.text`  
which holds code;

`.rodata`  
wihch holds data that will never be modified by the program.

`.data`  
which holds “initialised data,” that is, data that starts with a given
value; and

`.bss`  
which holds “uninitialised data,” that is, data that is supposed to
start off as zero.

No-one remembers what “BSS” stands for. Some people read it as “better
save space.” In some sense the `.bss` section is unnecessary: data in
this section is supposed to be initialised to zero before the program
begins so it could have been placed in the `.data` section. However, the
output file can be made smaller by not storing the actual zeros but
instead merely noting how much space they will need. When the program
starts, one of its first jobs will be to zero the memory locations (and
we will have to write code to do this). In addition, the data in the
`.data` section will need to be copied into RAM (and we will need to
write code to do this, as well).

There is one other input section, `.vectors`, which is not populated by
the C compiler but by a small piece of startup code (which we need to
write). It holds the “interrupt vector table,” a list of pointers to
code that is to be called by the hardware when various hardware events
happen. (I think this is “vector” in the sense of “pointer to
something,” rather than the sense of “one-dimensional array:” it is a
table of interrupt-vectors, not a vector of interrupts.) The way the CPU
gets started, after a reset, is first to load the stack pointer with the
address found in the four bytes at the beginning of the interrupt vector
table, and then to jump to the address in the following four bytes.

All of these input sections will be grouped by this linker script into
three output sections: `.text`, `.data`, and `.bss` (although I'm not
actually sure the output names matter). The contents of the `.text`
section will end up in flash memory and the contents of the `.data` and
`.bss` sections will (eventually) end up in RAM.
<sup><a href="#fn.1" id="fnr.1" class="footref" role="doc-backlink">1</a></sup>

If the input files contain other sections not specified in this script
(called “orphaned sections” by the GNU `ld` reference) then my
understanding is that they will be placed in the output file *somewhere*
by the linker anyway.
<sup><a href="#fn.2" id="fnr.2" class="footref" role="doc-backlink">2</a></sup>

<div class="org-src-container">

<span class="listing-number">Listing 2: </span>Output sections

``` src
SECTIONS {
  <<2.1 text output section>>
  <<2.2 data output section>>
  <<2.3 bss output section>>
}
```

</div>

</div>

<div id="outline-container-orgbbbe6a0" class="outline-4">

#### 2.1 Text output section

<div id="text-orgbbbe6a0" class="outline-text-4">

The `.text` output section gathers together all the parts of the input
that will end up in flash memory.

<div class="org-src-container">

<span class="listing-number">Listing 3: </span>Text output section

``` src
.text : {
  KEEP(*(.vectors))
  *(.text*)
  *(.rodata*)
} >FLASH
```

</div>

Each line of this part of the script specifies a set of input sections;
namely, those matching the pattern in the line. For example, the pattern
`*(.text*)` matches all input files (that's the first asterisk) and,
within those, all sections whose name begin with `.text` (that's the
second asterisk).
<sup><a href="#fn.3" id="fnr.3" class="footref" role="doc-backlink">3</a></sup>

The interrupt vectors section is wrapped in
“<span style="color: #859900;">`KEEP`</span>” because, as I understand
it, the linker may choose to omit (or “garbage collect”) sections that
don't appear to be referenced by the main sections.

</div>

</div>

<div id="outline-container-orgc784b54" class="outline-4">

#### 2.2 Data output section

<div id="text-orgc784b54" class="outline-text-4">

<div class="org-src-container">

<span class="listing-number">Listing 4: </span>Data output section

``` src
.data : ALIGN(4) {
  __data_start = .;
  *(.data)
  *(.data.*)
} >RAM AT >FLASH
__data_end = __data_start + SIZEOF(.data);  
```

</div>

The data section is tricky. It needs to say something like, “these input
sections should be loaded into flash memory but *look* as if it they are
present in RAM, in the sense that, whenever any of the addresses in
these sections are referenced, those references should point to the
section in `RAM`.” That's what
“`>RAM `<span style="color: #859900;">`AT`</span>` >FLASH`” does.
<sup><a href="#fn.4" id="fnr.4" class="footref" role="doc-backlink">4</a></sup>

I'm not sure why the two data lines aren't a single line, `*(.data*)`,
but this is what the Arm example linker script does so I have copied it.

Finally, this section begins with an alignment command: in this case,
that the section should start on a memory address divisible by four.
Obviously it will, because it will start at the origin of RAM, which is
divisible by four; but, again, the practice of putting in an
<span style="color: #6c71c4;">`ALIGN`</span> seems to be the norm.

</div>

</div>

<div id="outline-container-orgdce7297" class="outline-4">

#### 2.3 BSS output section

<div id="text-orgdce7297" class="outline-text-4">

<div class="org-src-container">

<span class="listing-number">Listing 5: </span>BSS output section

``` src
.bss : ALIGN(4) {
  __bss_start = .;
  *(.bss)
  *(.bss.*);
  . = ALIGN(4);
} >RAM
__bss_end = __bss_start + SIZEOF(.bss);
```

</div>

The `bss` output section merely reserves space (in RAM) for the
uninitialised data section. (Which I feel is something of a misnomer,
since it *will* be initialised, just to zero.)

</div>

</div>

</div>

<div id="outline-container-org20ea918" class="outline-3">

### 3. Entry point

</div>

</div>

<div id="outline-container-org0acb05a" class="outline-2">

## What is missing?

<div id="text-org0acb05a" class="outline-text-2">

1.  Exported symboles.

</div>

</div>

<div id="outline-container-org94d073f" class="outline-2">

## Sources

<div id="text-org94d073f" class="outline-text-2">

- I have taken the memory layout from the nRF52833 product
  specification.
- I have referred to both the Arm and Nordic Semiconductor example
  linker scripts (and startup files).
- The [GNU `ld`
  manual](https://sourceware.org/binutils/docs/ld/index.html) explains
  the meanings of the various parts of the linker script.

</div>

</div>

<div id="footnotes">

## Footnotes:

<div id="text-footnotes">

<div class="footdef">

<sup><a href="#fnr.1" id="fn.1" class="footnum" role="doc-backlink">1</a></sup>

<div class="footpara" role="doc-footnote">

The example linker script provided by Nordic Semiconductor breaks out
more of the input sections into their own output sections. I don't know
why one chooses one approach over another.

</div>

</div>

<div class="footdef">

<sup><a href="#fnr.2" id="fn.2" class="footnum" role="doc-backlink">2</a></sup>

<div class="footpara" role="doc-footnote">

We should probably run `ld` with `--orphan-handling=warn`.

</div>

</div>

<div class="footdef">

<sup><a href="#fnr.3" id="fn.3" class="footnum" role="doc-backlink">3</a></sup>

<div class="footpara" role="doc-footnote">

GCC emits multiple text sections when the option `-ffunction-sections`
is used.

</div>

</div>

<div class="footdef">

<sup><a href="#fnr.4" id="fn.4" class="footnum" role="doc-backlink">4</a></sup>

<div class="footpara" role="doc-footnote">

The terminology is as follows. The address of this section at run-time
is called the “virtual memory address” \[VMA\], whereas the address at
which the section is loaded into memory is called the “load memory
address” \[LMA\].

</div>

</div>

</div>

</div>

</div>

<div id="postamble" class="status">

Author: The Hut23 Compiler Club

Created: 2024-09-01 Sun 22:03

[Validate](https://validator.w3.org/check?uri=referer)

</div>
