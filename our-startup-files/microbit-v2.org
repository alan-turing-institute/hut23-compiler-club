#+title: Our BBC micro:bit v2 linker script
#+author: The Hut23 Compiler Club
#+options: toc:nil num:nil

* How to create the linker script

This file explains and is also the source of the linker script we have
developed for the micro:bit version 2, at least as far as we have
developed it, which is currently not very far.

To extract (or “tangle,” in literate-programming parlance) the script
itself, run ~make~ in this directory. That probably won't work on your
machine, but it's a start ...

* Overview
:PROPERTIES:
:header-args: :noweb no-export :exports code
:END:

The linker script is read by the linker (use the option “​~-T
microbit-v2.ld~​”). The main job of the linker script is:

In addition, the script might export names (or “symbols”) with which
to access particular memory locations. Here is the overall structure
of our overall script:

1. To describe the memory layout of the microbit; and
2. To arrange for the various “sections” of the program to end up in
   the correct places in memory in the output object file.

#+ATTR_LATEX: :float nil
#+name: Linker Script
#+begin_src ld-script :noweb-sep "arg" :tangle ./out/microbit-v2.ld
  /* 
  BBC micro:bit v2 linker script
  Written by the Hut23 Compiler Club
  Do not edit this file directly; instead edit the source ".org" file 
  */

  <<Memory layout>>
  <<Input and output sections>>
#+end_src

Each of the two parts is expanded below.


* Explanation of each part
:PROPERTIES:
:header-args: :noweb no-export :exports code
:END:

** Memory layout 

The Cortex M4 is a 32-bit CPU, meaning that it can in principle
address \(2^{32}\) bytes---or 4 GiB---of memory. However, the nRF52833
physically has only 512 kiB of flash memory and 128 kiB of RAM. The
mapping of that physical memory into the 4 GiB of “virtual” memory
space is described in the nRF52833 product specification (section
4.2.3, figure 3).

#+ATTR_LATEX: :float nil
#+name: Memory layout
#+caption: Memory layout of the Nordic nRF528333
#+begin_src ld-script
MEMORY {
  FLASH    (rx) : ORIGIN = 0x00000000, LENGTH = 512K  
  RAM      (wx) : ORIGIN = 0x20000000, LENGTH = 128K
  CODE_RAM (wx) : ORIGIN = 0x00800000, LENGTH = 128K 
}
#+end_src

(By the way, every linker file I've seen writes the attributes of the
RAM section as ~rw~ rather than (as here) just ~w~. However, the GNU
~ld~ manual (section 3.8) clearly says that the attribute ~w~ means
read /and/ write.)

On this device the 128 kiB of physical RAM is mapped /both/ to the
normal location (labelled as ~RAM~) and /also/ to an area of memory
just above the flash memory. This ~CODE_RAM~ is the same physical RAM,
just accessible from two different places in “memory.” The reason
seems to be that the CPU accesses this memory on a different bus and
that this can be faster if one is executing code. However, the rest of
this linker script ignores the code RAM.

There are other bits of memory---for example, the memory-mapped
peripheral registers, and some non-volatile configuration memory
regions---but I am unsure whether we should write that down here or
not. That does not seem to be the done thing but I am not entirely
sure why not.

** Input and output sections

The content of the linker’s input files and output file are assigned
to regions called “sections.” One job of the linker is to map the
sections in the input files to the sections in the output file and to
write in the output file where the output sections are to end up in
memory.

There are four conventional sections produced, for example, by the C
compiler which will be the input
sections to the linker. (There may be others but these seem to be the
critical ones.) They are:

- ~.text~ :: which holds code;
- ~.rodata~ :: wihch holds data that will never be modified by the program.
- ~.data~ :: which holds “initialised data,” that is, data that starts
  with a given value; and
- ~.bss~ :: which holds “uninitialised data,” that is, data that is
  supposed to start off as zero.

No-one remembers what “BSS” stands for. Some people read it as “better
save space.” In some sense the ~.bss~ section is unnecessary: data in
this section is supposed to be initialised to zero before the program
begins so it could have been placed in the ~.data~ section. However,
the final output file can be made smaller by not storing the actual
zeros but instead merely noting how much space they will need. When
the program starts, one of its first jobs will be to zero the memory
locations (and we will have to write code to do this). In addition,
the data in the ~.data~ section will need to be copied into RAM
(although the data in the ~.rodata~ section can stay where it is, in
flash memory).

There is one other input section, ~.vectors~, which is not generated
by the C compiler but by a small piece of startup code (which we need
to write). It holds the “interrupt vector table,” a list of pointers
to code that is to be called by the hardware when various hardware
events happen. (I think this is “vector” in the sense of “pointer to
something:” it is a table of interrupt vectors table, not a
vector-table of interrupts.) The way the CPU gets started, after a
reset, is to first load the stack pointer with the address found in
the four bytes at the beginning of the interrupt vector table, and
then to jump to the address in the four bytes starting at 0x4. 

All of these input sections will be grouped by this linker script into
three output sections: ~.text~, ~.data~, and ~.bss~ (although I'm not
actually sure the output names matter). The contents of the ~.text~
section will end up in flash memory and the contents of the ~.data~
and ~.bss~ sections will (eventually) end up in RAM. [fn:1]

#+ATTR_LATEX: :float nil
#+name: Output sections
#+caption: Output sections
#+begin_src ld-script
  SECTIONS {
    <<text output section>>
    <<data output section>>
    <<bss output section>>
  }
#+end_src

*** Text output section

The ~.text~ output section gathers together all the parts of the input
that will end up in flash memory.

#+ATTR_LATEX: :float nil
#+name: text output section
#+caption: Text output section
#+begin_src ld-script 
    .text : {
      KEEP(*(.vectors))
      *(.text*)
      *(.rodata*)
    } >FLASH
#+end_src

Each line of this part of the script specifies a set of input
sections: those matching the pattern in the line. For example, the
pattern src_ld-script{*(.text*)} matches all input files (that's the
first asterisk) and, within those, all sections whose name begin with
`src_ld-script{.text}' (that's the second asterisk). [fn:2]

The initial input section, the interrupt-vectors table, will be
defined in another file (probably an assembly file). It is wrapped in
“KEEP” because, as I understand it, the linker may choose to omit (or
“garbage collect”) sections that don't appear to be referenced by the
main sections.

*** Data output section

#+ATTR_LATEX: :float nil
#+name: data output section
#+caption: Data output section
#+begin_src ld-script 
    .data : {
      *(.data*)
    } >RAM >AT FLASH
#+end_src

The data section is tricky. It needs to say something like, “this
section should be loaded into flash memory but /look/ as if it is
present in RAM, in the sense that, whenever any of the addresses in
this section are /referenced/, those references should point to the
section in ~RAM~.” That's what “src_ld-script{>RAM >AT FLASH}” does.

*** BSS output section

#+ATTR_LATEX: :float nil
#+name: bss output section
#+caption: BSS output section
#+begin_src ld-script 
    .bss : {
    
    } >FLASH
#+end_src



The script above gathers together all ~.text~ sections in all input
files (that's what ~*(.text)~ means) and groups them together in a
single output section, also labelled ~.text~, which is itself to be
placed in the flash memory. In other words, code in the input file
will end up written into memory from 0x0 onwards.

This script is wrong for lots of reasons. One is that in fact the
first part of memory has to hold data that the CPU will use. On reset,
the CPU loads the stack pointer with the address found in the four
bytes starting at 0x0, and then commences executing code at the
address in the four bytes starting at 0x4. In addition, the memory
from 0x8 up possibly to 0x400 should contain pointers to interrupt
handlers, known as the “nested vector interrupt table.” (That's how
the CPU knows what code to run when interrupts happen.) So we should
at the very least have reserved space for nested vector interrupt
table.

* What is missing?

1. Exported symboles.
   

* Sources

I have taken the memory layout from the [[../reference/SoC/nRF52833_PS_v1.7.pdf][nRF52833 product
specification]]. 

Both Arm and Nordic Semiconductor produce example linker scripts (and
startup files):

- For Arm, there is a GitHub repo called [[https://github.com/ARM-software/CMSIS_6][CMSIS]] (for “Common
  Microcontroller Software Interface Standard”). There is a linker
  script in [[https://github.com/ARM-software/CMSIS_6/tree/main/CMSIS/Core/Template/Device_M/Config][~CMSIS/Core/Template/Device_M/Config/Device_gcc.ld~]].

- Nordic publish a repo called [[https://github.com/NordicSemiconductor/nrfx][nrfx]]. There is an nRF52833-specific
  linker script in [[https://github.com/NordicSemiconductor/nrfx/tree/master/mdk][~mdk/nrf52833_xxaa.ld~]] (in fact, there is a /lot/
  of nRF528333-specific information in that directory).

Those files contain many more sections, partly to support C++ and
partly for other reasons I don't understand.

The [[https://sourceware.org/binutils/docs/ld/index.html][GNU ~ld~ manual]] explains the meanings of the various parts of the
linker script. 


* Footnotes
[fn:2] GCC emits multiple text sections when the option
~-ffunction-sections~ is used.

[fn:1] The example linker script provided by Nordic Semiconductor
breaks out more of the input sections into their own output
sections. I don't know why one chooses one approach over another.
