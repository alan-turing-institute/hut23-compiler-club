:PROPERTIES:
:header-args: :noweb no-export :exports code :comments noweb :padline yes
:END:
#+title: Our BBC micro:bit v2 linker script
#+author: The Hut23 Compiler Club
#+options: toc:nil num:nil

* How to create the linker script

The linker script lives in [[./out/microbit-v2.ld]]. To create both the
script and this README, run ~make~ in this directory. (You will need
to have Emacs installed.)

The source of this explanation and the script itself is the file
[[./microbit-v2.org]]. Edit that file rather than the script.

The file [[empty.s]] contains no code or data. Try ~make empty~ to run the
assembler on this file and then link with the linker script. The file
[[mostly-empty.s]] contains five bytes of data (in the form of a
null-terminated string) in each section. Try ~make mostly-empty~ to
see how the result is arranged in memory by the linker. 


* Overview

The input to the linker (eg, GNU ~ld~) is a set of files, known as
/object files/, containing code (in binary format) and data. The job
of the linker is to combine all the code and data in the input files
into a single output file, also known as an object file, that can be
loaded into a particular region of memory (or, in our case, flashed
onto the micro:bit).

However, when input object files are generated---for example by a C
compiler or an assembler---their final location in memory is not
known. Thus the files contain, not hard-coded memory locations, but
/symbols/: stand-ins for the final location of code or data. Each
symbol is defined in one of the input files to point to a particular
part of the data, or code, in that input file. The linker must decide
to what final location each symbol will refer to and arrange for all
the references to that symbol, in whatever file the reference occurs,
to refer to that location.

The linker script is a configuration file read by the linker (use the
option “​~-T microbit-v2.ld~​”). The purpose of the linker script is:

1. To describe the memory layout of the micro:bit; 
2. To arrange for the various “sections” of code and data to end up in
   the correct places in memory in the output object file; and
3. To name and make globally available particular locations in memory
   that can only be decided at link time but which are referenced by
   the code.

Here is the overall structure of our script:

#+ATTR_LATEX: :float nil
#+name: Linker Script
#+begin_src ld-script :tangle ./out/microbit-v2.ld 
  /* 
  BBC micro:bit v2 linker script
  Written by the Hut23 Compiler Club
  Do not edit this file directly; instead edit the source ".org" file 
  ,*/

  <<1. Memory layout>>
  <<2. Input and output sections>>
  <<3. Global symbols>>
#+end_src

Each part is expanded below.


* Explanation of each part

** 1. Memory layout 

The Cortex M4 is a 32-bit CPU, meaning that it can in principle
address \(2^{32}\) bytes---or 4 GiB---of memory. However, the nRF52833
physically only has 512 kiB of flash memory and 128 kiB of RAM (see
section 4.2.3, figure 3, of the nRF52833 product specification). The
mapping of that physical memory into the 4 GiB of “virtual” memory
space is described by the first part of the linker script.

#+ATTR_LATEX: :float nil
#+name: 1. Memory layout
#+caption: Memory layout of the Nordic nRF528333
#+begin_src ld-script
MEMORY {
  FLASH    (rx)  : ORIGIN = 0x00000000, LENGTH = 512K  
  RAM      (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
  CODE_RAM (rwx) : ORIGIN = 0x00800000, LENGTH = 128K 
}
#+end_src

(By the way, every linker file I've seen writes the attributes of the
RAM section as ~rwx~ even though the GNU ~ld~ manual, section 3.8,
clearly says that the attribute ~w~ means read /and/ write.)

On this device the 128 kiB of physical RAM is mapped /both/ to the
normal location (labelled as ~RAM~) and /also/ to an area of memory
just above the flash memory. This ~CODE_RAM~ is the same physical RAM,
just accessible from two different places in “memory.” The reason
seems to be that the CPU accesses this memory on a different bus and
that this can be faster if one is executing code. However, the rest of
this linker script ignores the code RAM.

There are other bits of memory---for example, the memory-mapped
peripheral registers, and some non-volatile configuration memory
regions---but I am unsure whether we should write that down here or
not. That does not seem to be the done thing but I am not entirely
sure why not.

** 2. Input and output sections

The content of the linker’s input files and output file are assigned
to regions called “sections.” One job of the linker is to map the
sections in the input files to the sections in the output file and to
write in the output file where the output sections are to end up in
memory.

There are four conventional input sections produced, for example, by
the C compiler, which will be the input sections to the linker. (There
may be others but these seem to be the critical ones.) They are:

- ~.text~ :: which holds code;
- ~.rodata~ :: wihch holds data that will never be modified by the
  program.
- ~.data~ :: which holds “initialised data,” that is, data that starts
  with a given value; and
- ~.bss~ :: which holds “uninitialised data,” that is, data that is
  supposed to start off as zero.

No-one remembers what “BSS” stands for. Some people read it as “better
save space.” In some sense the ~.bss~ section is unnecessary: data in
this section is supposed to be initialised to zero before the program
begins, so it could have been placed in the ~.data~ section. However,
the output file can be made smaller by not storing the actual zeros
but instead merely noting how much space they will need. When the
program starts, one of its first jobs will be to zero the memory
locations (and we will have to write code to do this). In addition,
the data in the ~.data~ section will need to be copied into RAM
(and we will need to write code to do this, as well).

There is one other input section, ~.vectors~, which is not populated
by the C compiler but by a small piece of startup code (which we need
to write). It holds the “interrupt vector table,” a list of pointers
to code that is to be called by the hardware when various hardware
events happen. (I think this is “vector” in the sense of “pointer to
something,” rather than the sense of “one-dimensional array:” it is a
table of interrupt-vectors, not a vector of interrupts.) The way the
CPU gets started, after a reset, is first to load the stack pointer
with the address found in the four bytes at the beginning of the
interrupt vector table, and then to jump to the address in the
following four bytes.

All of these input sections will be grouped by this linker script into
three output sections: ~.text~, ~.data~, and ~.bss~ (although I'm not
actually sure the output names matter). The contents of the ~.text~
section will end up in flash memory and the contents of the ~.data~
and ~.bss~ sections will (eventually) end up in RAM. [fn:1]

If the input files contain other sections not specified in this script
(called “orphaned sections” by the GNU ~ld~ reference) then my
understanding is that they will be placed in the output file
/somewhere/ by the linker anyway. [fn:3]

#+ATTR_LATEX: :float nil
#+name: 2. Input and output sections
#+caption: Output sections
#+begin_src ld-script :noweb no-export
  SECTIONS {
    <<2.1 text output section>>
    <<2.2 data output section>>
    <<2.3 bss output section>>
  }
#+end_src

*** 2.1 Text output section

The ~.text~ output section gathers together all the parts of the input
that will end up in flash memory: the vector table, program code, and
read-only daya. 

#+ATTR_LATEX: :float nil
#+name: 2.1 text output section
#+caption: Text output section
#+begin_src ld-script 
    .text : {
      KEEP(*(.vectors))
      *(.text*)
      *(.rodata*)
    } >FLASH
#+end_src

Each line of this part of the script specifies a set of input
sections; namely, those matching the pattern in the line. For example,
the pattern src_ld-script{*(.text*)} matches all input files (that's
the first asterisk) and, within those, all sections whose name begin
with src_ld-script{.text} (that's the second asterisk). [fn:2]

The ~.vectors~ section is wrapped in src_ld-script{KEEP} because, as I
understand it, the linker may choose to omit (or “garbage collect”)
sections that don't appear to be referenced by the main sections.

*** 2.2 Data output section

The data section is tricky. It contains the initial values of data
that the program may need to change during the course of its
execution. Thus, although this section should be loaded into flash
memory, it will need to be moved to RAM and all the symbols within it
should resolve to addresses in RAM.

The terminology is as follows. The address of the section at run-time
(in RAM) is called the “virtual memory address” [VMA]. The address at
which the section is loaded into memory (that is, in flash memory) is
called the “load memory address” [LMA]. Thus, the linker must arrange
for this section to be loaded at the LMA but resolve symbols within it
to point to VMA.

Of course, the data /isn't/ at the VMA when the program starts. It's
at the LMA! As a startup action, therefore, the program itself will
need to copy the data from the LMA to the VMA. 

Schematically, the linker syntax for output sections is as follows:
#+begin_src ld-script :noweb no
.data [VMA address] : [LMA address] {
   input sections, ...
} >[VMA memory] AT >[LMA memory]
#+end_src

The VMA and LMA addresses do not need to be specified explicitly. The
linker puts the section in the next available memory after the last
section in the same region.

However, it will be convenient (when we come to write the code to move
the data from LMA to VMA) to have this section start and end on a
four-byte boundary because that is the size of a single register in
the CPU. At each point in the linker script, the /location counter/,
denoted by a period, is the address of the current section, relative
to the nearest enclosing scope. The command src_ld-script{ALIGN(4)}
returns the value of the location counter, incremented if necessary to
the next location divisible by four. A typical way to ensure the
location counter is aligned is to write something like
#+begin_src ld-script :noweb no
  ...
  . = ALIGN(4);
  ...
#+end_src
in the script. That assigns the aligned value of the location counter
back to the location counter. However, outside the ~.data~ section the
location counter refers to the VMA, whereas inside the ~.data~ section
it will (I think, it's confusing) refer to the /offset/ from the
beginning of the session. In neither case will it align the start of
the LMA (which also need to do). The follow approach seems (after much
experimentation!) do to the right thing:

#+ATTR_LATEX: :float nil
#+name: 2.2 data output section
#+caption: Data output section
#+begin_src ld-script
  .data : ALIGN(4) {
      *(.data)
      *(.data.*)
      . = ALIGN(4);
    } >RAM AT >FLASH
#+end_src

In the ~[LMA address]~ part of the header line, we assign the LMA to
the aligned location counter (which at this point happens to be the
LMA). As far as I can tell, ~ld~ will /also/ ensure that the VMA
address is similarly aligned, although the manual does not make this
clear. At the end of the section the final align command pads the
section, if necessary so that the section is guaranteed to have a
length that is a multiple of four.

It's necessary to export symbols that refer to the actual locations of
the LMA and VAM (so that the startup code can move the data from one
to the other). It is common practice to to this by defining, at
particular points in the script, symbols which refer to the location
counter at that point. For example, one might write ~__data_start =
.;~ to export the beginning of the data section. I don't know why
people do this, since one can also write ~__data_start = ADDR(.data);~
(and that is what we will below). My current hypothesis is that it's
historical but I am slightly worried that there's an edge case I have
not understood. (It is definitely true that things are more
complicated than they might appear: see, e.g., the GNU ~ld~ manual,
[[https://sourceware.org/binutils/docs/ld.html#Location-Counter][section 3.10.5]].

One last note: I'm not sure why the two data lines aren't a single
line, src_ld-script{*(.data*)}, but this is what the Arm example linker
script does so I have copied it.

*** 2.3 BSS output section

The src_ld-script{bss} output section merely reserves space (in RAM)
for the uninitialised data section. (Which I feel is something of a
misnomer, since it /will/ be initialised, just to zero.) We use the
same alignment trick as before.

#+ATTR_LATEX: :float nil
#+name: 2.3 bss output section
#+caption: BSS output section
#+begin_src ld-script 
  .bss : ALIGN(4) {
    *(.bss)
    *(.bss.*);
    . = ALIGN(4);
  } >RAM
#+end_src

** 3. Global symbols

This part of the script defines symbols containing the addresses of
the start and end of various sections.

#+ATTR_LATEX: :float nil
#+name: 3. Global symbols
#+begin_src ld-script  
  /* All the memory from the end of bss to the top of RAM */
  __heap_start = .;
  __stack_top = ORIGIN(RAM) + LENGTH(RAM);

  /* VMA of the .data section */
  __data_start = ADDR(.data); 
  __data_end   = __data_start + SIZEOF(.data);

  /* LMA of the .data section */
  __data_load_start = LOADADDR(.data);
  
  /* VMA of the .bss section */
  __bss_start = ADDR(.bss);
  __bss_end   = __bss_start + SIZEOF(.bss);

  /* Entry point (for gdb */
  ENTRY(Reset_Handler);
#+end_src

The area between ~__heap_start~ and ~stack_top~ is all the RAM that is
usable by the program at runtime. (By the way, there are presumably
naming conventions for these things which I am not sure I am
respecting.) Then we need the locations of the ~.data~ and ~.bss~
sections. Finally, it is apparently helpful to define the “entry
point” to the program, because it helps ~GDB~ (the GNU debugger). At
some point, we wil have to write this code as well and assign the
label ~Entry_Handler~. .


* Sources

- I have taken the memory layout from the nRF52833 product
  specification.

- I have referred to both the Arm and Nordic Semiconductor example
  linker scripts (and startup files).

- The [[https://sourceware.org/binutils/docs/ld/index.html][GNU ~ld~ manual]] explains the meanings of the various parts of
  the linker script.


* Footnotes

[fn:1] The example linker script provided by Nordic Semiconductor
breaks out more of the input sections into their own output
sections. I don't know why one chooses one approach over another.

[fn:2] GCC emits multiple text sections when the option
~-ffunction-sections~ is used.

[fn:3] We should probably run ~ld~ with ~--orphan-handling=warn~.


