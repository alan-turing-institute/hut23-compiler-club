:PROPERTIES:
:header-args: :noweb no-export :exports code :padline yes
:END:
#+title: Our BBC micro:bit v2 linker script
#+author: The Hut23 Compiler Club
#+options:

num:nil 

* Introduction

** Creating the linker script from this file

The linker script, [[./out/microbit-v2.ld]], as well as this README, are
generated from the file [[./microbit-v2.org]]. To create the script and
this document, run ~make~ in this directory. (You will need to have
Emacs installed.)

The file [[./empty.s]] contains no code or data. Try ~make empty~ to
run the assembler on this file and then link with the linker
script. The file [[./nearly-empty.s]] contains five bytes of data (in
the form of a null-terminated string) in each section. Try ~make
nearly-empty~ to see how the result is arranged in memory by the
linker.

** What is a linker script for? 

In brief, the linker amalgamates one or more compiled input files into
a final output file and resolves any references within and between the
files; this process of linking is controlled by the linker script.

Linking is the final stage of the three-stage process for converting a
program written in a high-level language into an executable “binary.”
First, high-level C code, say, is converted by the compiler into
low-level assembly language, the human-readable form of the CPU's
native instructions (with a few convenience features). Then the
assembly language file is converted, by the assembler, into a binary
file, known as an “object file.” Finally, the object file, and
possibly other object files arising from the compilation of other
high-level language files, are combined by the linker into a single
output file---also known as an object file---which can be loaded into
a particular region of memory (or, in our case, flashed onto the
micro:bit).

When the input files are generated by the compiler and assembler their
final location in memory is not known. Thus the input object files
contain, not hard-coded memory locations, but /symbols/: stand-ins for
the final location of code or data. Each symbol is defined in one of
the input files to point to a particular part of the data, or code, in
that input file. The linker must decide to what final location each
symbol will refer and arrange for all the references to that symbol,
in whatever file the reference occurs, to refer to that location.

The linker script is a configuration file read by the linker (use the
option “​~-T microbit-v2.ld~​”). The purpose of the linker script is
therefore:

1. To describe the memory layout of the micro:bit; 
2. To arrange for the various “sections” of code and data to end up in
   the correct places in memory in the output object file; and
3. To name and make globally available particular locations in memory
   that can only be decided at link time but which are referenced by
   the code.


* Our linker script in full

Here is the linker script, in full, divided into three sections which
reflect the description in the previous section:

#+ATTR_LATEX: :float nil
#+name: Linker Script
#+begin_src ld-script :noweb yes :tangle ./out/microbit-v2.ld 
  /* 
  BBC micro:bit v2 linker script
  Written by the Hut23 Compiler Club
  Do not edit this file directly; instead edit the source ".org" file 
  */

  <<Memory layout>>

  <<Input and output sections>>

  <<Global symbols>>
#+end_src


* Details

** Memory layout 

The Cortex M4 is a 32-bit CPU, meaning that it can in principle
address \(2^{32}\) bytes---or 4 GiB---of memory. However, the nRF52833
physically only has 512 kiB of flash memory and 128 kiB of RAM (see
section 4.2.3, figure 3, of the nRF52833 product specification). The
mapping of that physical memory into the 4 GiB of “virtual” memory
space is described by the first part of the linker script.

#+ATTR_LATEX: :float nil
#+name: Memory layout
#+caption: Memory layout of the Nordic nRF528333
#+begin_src ld-script
MEMORY {
  FLASH    (rx)  : ORIGIN = 0x00000000, LENGTH = 512K  
  RAM      (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
  CODE_RAM (rwx) : ORIGIN = 0x00800000, LENGTH = 128K 
}
#+end_src

(By the way, every linker file I've seen writes the attributes of the
RAM section as ~rwx~ even though the GNU ~ld~ manual, section 3.8,
clearly says that the attribute ~w~ means read /and/ write.)

On this device the 128 kiB of physical RAM is mapped /both/ to the
normal location (labelled as ~RAM~) and /also/ to an area of memory
just above the flash memory. This ~CODE_RAM~ is the same physical RAM,
just accessible from two different places in “memory.” The reason
seems to be that the CPU accesses this memory on a different bus and
that this can be faster if one is executing code. However, the rest of
this linker script ignores the code RAM.

There are other bits of memory---for example, the memory-mapped
peripheral registers, and some non-volatile configuration memory
regions---but I am unsure whether we should write that down here or
not. That does not seem to be the done thing but I am not entirely
sure why not.

** Input and output sections

The content of the linker’s input files and output file are assigned
to regions called “sections.” One job of the linker is to map the
sections in the input files to the sections in the output file and to
write in the output file where the output sections are to end up in
memory.

There are four conventional input sections produced, for example, by
the C compiler, which will be the input sections to the linker. (There
may be others but these seem to be the critical ones.) They are:

- ~.text~ :: which holds code;
- ~.rodata~ :: which holds read-only data that will never be modified
  by the program.
- ~.data~ :: which holds “initialised data,” that is, data that starts
  with a given value; and
- ~.bss~ :: which holds “uninitialised data,” that is, data that is
  supposed to start off as zero.

No-one remembers what “BSS” stands for. (Some people read it as “better
save space.”) In some sense the ~.bss~ section is unnecessary: data in
this section is supposed to be initialised to zero before the program
begins, so it could have been placed in the ~.data~ section. However,
the output file can be made smaller by not storing the actual zeros
but instead merely noting how much space they will need. When the
program starts, one of its first jobs will be to zero the memory
locations (and we will have to write code to do this). In addition,
the data in the ~.data~ section will need to be copied into RAM
(and we will need to write code to do this, as well).

There is one other input section, ~.vectors~, which is not populated
by the C compiler but by a small piece of startup code (which we need
to write). It holds the “interrupt vector table,” a list of pointers
to code that is to be called by the hardware when various hardware
events happen. (I think this is “vector” in the sense of “pointer to
something,” rather than the sense of “one-dimensional array:” it is a
table of interrupt-vectors, not a vector of interrupts.) The way the
CPU gets started, after a reset, is first to load the stack pointer
with the address found in the four bytes at the beginning of the
interrupt vector table, and then to jump to the address in the
following four bytes.

All of these input sections will be grouped by this linker script into
three output sections: ~.text~, ~.data~, and ~.bss~ (although I'm not
actually sure the output names matter). The contents of the ~.text~
section will end up in flash memory and the contents of the ~.data~
and ~.bss~ sections will (eventually) end up in RAM. [fn:1]

If the input files contain other sections not specified in this script
(called “orphaned sections” by the GNU ~ld~ reference) then my
understanding is that they will be placed in the output file
/somewhere/ by the linker anyway. [fn:3]

#+ATTR_LATEX: :float nil
#+name: Input and output sections
#+caption: Output sections
#+begin_src ld-script :noweb no-export
  SECTIONS {
    <<.text output section>>
    <<.data output section>>
    <<.bss output section>>
  }
#+end_src

*** Text output section

The ~.text~ output section gathers together all the parts of the input
that will end up in flash memory: the vector table, program code, and
read-only data. 

#+ATTR_LATEX: :float nil
#+name: .text output section
#+caption: Text output section
#+begin_src ld-script 
    .text : {
      KEEP(*(.vectors))
      *(.text*)
      *(.rodata*)
    } >FLASH
#+end_src

The opening ~.text~ names the output section. Each line within the
curly braces specifies a set of input sections; namely, those matching
the pattern in the line. For example, the pattern
src_ld-script{*(.text*)} matches all input files (that's the first
asterisk) and, within those, all sections whose name begin with
src_ld-script{.text} (that's the second asterisk). [fn:2]

The ~.vectors~ section is wrapped in src_ld-script{KEEP} because, as I
understand it, the linker may choose to omit (or “garbage collect”)
orphan sections and we really want to keep this one.

*** Data output section

The data section is tricky. It contains the initial values of data
that the program may need to change during the course of its
execution. Thus, although this section should be loaded into flash
memory, it will need to be copied to RAM and so all the symbols within
it should resolve to addresses in RAM.

The terminology is as follows. The address of the section at run-time
(in RAM) is called the “virtual memory address” [VMA]. The address at
which the section is loaded into memory (that is, in flash memory) is
called the “load memory address” [LMA]. Thus, the linker must arrange
for this section to be loaded at the LMA but resolve symbols within it
to point to VMA.

Of course, the data /isn't/ at the VMA when the program starts. It's
at the LMA! As a startup action, therefore, the program itself will
need to copy the data from the LMA to the VMA. 

Schematically, the linker syntax for output sections is as follows:
#+begin_src ld-script :noweb no
.data [VMA address] : [LMA address] {
   input sections, ...
} >[VMA memory] AT >[LMA memory]
#+end_src

The VMA and LMA addresses do not need to be specified explicitly. The
linker puts the section in the next available memory after the last
section in the same region.

However, it will be convenient (when we come to write the code to copy
the data from LMA to VMA) to have this section start and end on a
four-byte boundary because that is the size of a single register in
the CPU. At each point in the linker script, the /location counter/,
denoted by a period, is the address of the current item, relative to
the nearest enclosing scope. The command src_ld-script{ALIGN(4)}
returns the value of the location counter, incremented (if necessary)
to the next location divisible by four. A typical way to ensure the
location counter is aligned is to write something like
#+begin_src ld-script :noweb no
  ...
  . = ALIGN(4);
  ...
#+end_src
in the script. That assigns the aligned value of the location counter
back to the location counter. However, outside the ~.data~ section the
location counter refers to the VMA, whereas inside the ~.data~ section
it will (I think, it's confusing) refer to the /offset/ from the
beginning of the session. In neither case will it align the start of
the LMA (which it also needs to do). The follow approach seems (after
much experimentation!) do to the right thing:

#+ATTR_LATEX: :float nil
#+name: .data output section
#+caption: Data output section
#+begin_src ld-script
  .data : ALIGN(4) {
      *(.data)
      *(.data.*)
      . = ALIGN(4);
  } >RAM AT >FLASH
#+end_src

In the ~[LMA address]~ part of the header line, we assign the LMA to
the aligned location counter (which at this point happens to be the
LMA). As far as I can tell, ~ld~ will /also/ ensure that the VMA
address is similarly aligned, although the manual does not make this
clear. At the end of the section the final align command pads the
section (if necessary) so that the section is guaranteed to have a
length that is a multiple of four.

It's necessary to export symbols that refer to the actual locations of
the LMA and VMA (so that the startup code can copy the data from one
to the other). It is common practice to to this by defining, at
particular points in the script, symbols which refer to the location
counter at that point. For example, one might write ~__data_start =
.;~ to export the beginning of the data section. I don't know why
people do this, since one can also write ~__data_start = ADDR(.data);~
(and that is what we will in fact do). My current hypothesis is that
it's historical but I am slightly worried that there's an edge case I
have not understood. (It is definitely true that things are more
complicated than they might appear: see, e.g., the GNU ~ld~ manual,
[[https://sourceware.org/binutils/docs/ld.html#Location-Counter][section 3.10.5]].)

One last note: I'm not sure why the two data lines aren't a single
line, src_ld-script{*(.data*)}, but this is what the Arm example linker
script does so I have copied it.

*** BSS output section

The src_ld-script{bss} output section merely reserves space (in RAM)
for the uninitialised data section. (Which I feel is something of a
misnomer, since it /will/ be initialised, just to zero.) We use the
same alignment trick as before.

#+ATTR_LATEX: :float nil
#+name: .bss output section
#+caption: BSS output section
#+begin_src ld-script 
  .bss : ALIGN(4) {
    *(.bss)
    *(.bss.*);
    . = ALIGN(4);
  } >RAM
#+end_src

** Global symbols

This part of the script defines symbols containing the addresses of
the start and end of various sections.

#+ATTR_LATEX: :float nil
#+name: Global symbols
#+begin_src ld-script  
  /* All the memory from the end of bss to the top of RAM */
  __heap_start = .;
  __stack_top = ORIGIN(RAM) + LENGTH(RAM);

  /* VMA of the .data section */
  __data_start = ADDR(.data); 
  __data_end   = __data_start + SIZEOF(.data);

  /* LMA of the .data section */
  __data_load_start = LOADADDR(.data);
  
  /* VMA of the .bss section */
  __bss_start = ADDR(.bss);
  __bss_end   = __bss_start + SIZEOF(.bss);

  /* Entry point (for gdb) */
  ENTRY(Reset_Handler);
#+end_src

The area between ~__heap_start~ and ~__stack_top~ is all the RAM that
is usable by the program at runtime. (By the way, there are presumably
naming conventions for these things which I am not sure I am
respecting.) Then we need the locations of the ~.data~ and ~.bss~
sections. Finally, it is apparently helpful to define the “entry
point” to the program, because it helps ~GDB~ (the GNU debugger). At
some point, we will have to write this startup code and assign the
label ~Reset_Handler~ to it.


* Sources

- I have taken the memory layout from the nRF52833 product
  specification.

- I have referred to both the Arm and Nordic Semiconductor example
  linker scripts (and startup files).

- The [[https://sourceware.org/binutils/docs/ld/index.html][GNU ~ld~ manual]] explains the meanings of the various parts of
  the linker script.


* Footnotes

[fn:1] The example linker script provided by Nordic Semiconductor
breaks out more of the input sections into their own output
sections. I don't know why one chooses one approach over another.

[fn:2] GCC emits multiple text sections when the option
~-ffunction-sections~ is used.

[fn:3] We should probably run ~ld~ with ~--orphan-handling=warn~.


