---
author: The Hut23 Compiler Club
title: "Our BBC micro:bit v2 linker script"
---

# How to create the linker script

This README was generated from the file
[file:./microbit-v2.org](./microbit-v2.org). That file also generates
the linker script, [file:./out/microbit-v2.ld](./out/microbit-v2.ld). To
create both this document and the script, run `make` in this directory.
(You will need to have Emacs installed.)

The file [file:./empty.s](./empty.s) contains no code or data. Try
`make empty` to run the assembler on this file and then link with the
linker script. The file [file:./nearly-empty.s](./nearly-empty.s)
contains five bytes of data (in the form of a null-terminated string) in
each section. Try `make
mostly-empty` to see how the result is arranged in memory by the linker.

# Overview

A C compiler converts high-level code into low-level assembly language
instructions. Assembly language is a human-readable form of the CPU's
native instructions with a few convenience features (such as symbolic
naming of memory locations). The assembler turns this human-readable
file into a binary file, known as an “object file.” For example, the
assembler instruction `movs r0, #10`, meaning “move the number 10 to
register `r0`,” is converted to the two-byte sequence `20` `0a` (in
hexadecimal).

The final stage of compilation is to pass the object file (or files) to
the linker (GNU `ld`). The job of the linker is to combine all the code
and data in the input files into a single output file—also known as an
object file—which can be loaded into a particular region of memory (or,
in our case, flashed onto the micro:bit).

However, when the input files are generated their final location in
memory is not known. Thus the files contain, not hard-coded memory
locations, but *symbols*: stand-ins for the final location of code or
data. Each symbol is defined in one of the input files to point to a
particular part of the data, or code, in that input file. The linker
must decide to what final location each symbol will refer and arrange
for all the references to that symbol, in whatever file the reference
occurs, to refer to that location.

The linker script is a configuration file read by the linker (use the
option “​`-T microbit-v2.ld`​”). The purpose of the linker script is:

1.  To describe the memory layout of the micro:bit;
2.  To arrange for the various “sections” of code and data to end up in
    the correct places in memory in the output object file; and
3.  To name and make globally available particular locations in memory
    that can only be decided at link time but which are referenced by
    the code.

Here is the overall structure of our script:

``` ld-script
/* 
BBC micro:bit v2 linker script
Written by the Hut23 Compiler Club
Do not edit this file directly; instead edit the source ".org" file 
*/

<<1. Memory layout>>
<<2. Input and output sections>>
<<3. Global symbols>>
```

Each part is expanded below.

# Explanation of each part

## 1. Memory layout

The Cortex M4 is a 32-bit CPU, meaning that it can in principle address
$2^{32}$ bytes—or 4 GiB—of memory. However, the nRF52833 physically only
has 512 kiB of flash memory and 128 kiB of RAM (see section 4.2.3,
figure 3, of the nRF52833 product specification). The mapping of that
physical memory into the 4 GiB of “virtual” memory space is described by
the first part of the linker script.

<div class="captioned-content">

<div class="caption">

Memory layout of the Nordic nRF528333

</div>

``` ld-script
MEMORY {
  FLASH    (rx)  : ORIGIN = 0x00000000, LENGTH = 512K  
  RAM      (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
  CODE_RAM (rwx) : ORIGIN = 0x00800000, LENGTH = 128K 
}
```

</div>

(By the way, every linker file I've seen writes the attributes of the
RAM section as `rwx` even though the GNU `ld` manual, section 3.8,
clearly says that the attribute `w` means read *and* write.)

On this device the 128 kiB of physical RAM is mapped *both* to the
normal location (labelled as `RAM`) and *also* to an area of memory just
above the flash memory. This `CODE_RAM` is the same physical RAM, just
accessible from two different places in “memory.” The reason seems to be
that the CPU accesses this memory on a different bus and that this can
be faster if one is executing code. However, the rest of this linker
script ignores the code RAM.

There are other bits of memory—for example, the memory-mapped peripheral
registers, and some non-volatile configuration memory regions—but I am
unsure whether we should write that down here or not. That does not seem
to be the done thing but I am not entirely sure why not.

## 2. Input and output sections

The content of the linker’s input files and output file are assigned to
regions called “sections.” One job of the linker is to map the sections
in the input files to the sections in the output file and to write in
the output file where the output sections are to end up in memory.

There are four conventional input sections produced, for example, by the
C compiler, which will be the input sections to the linker. (There may
be others but these seem to be the critical ones.) They are:

`.text`  
which holds code;

`.rodata`  
wihch holds data that will never be modified by the program.

`.data`  
which holds “initialised data,” that is, data that starts with a given
value; and

`.bss`  
which holds “uninitialised data,” that is, data that is supposed to
start off as zero.

No-one remembers what “BSS” stands for. Some people read it as “better
save space.” In some sense the `.bss` section is unnecessary: data in
this section is supposed to be initialised to zero before the program
begins, so it could have been placed in the `.data` section. However,
the output file can be made smaller by not storing the actual zeros but
instead merely noting how much space they will need. When the program
starts, one of its first jobs will be to zero the memory locations (and
we will have to write code to do this). In addition, the data in the
`.data` section will need to be copied into RAM (and we will need to
write code to do this, as well).

There is one other input section, `.vectors`, which is not populated by
the C compiler but by a small piece of startup code (which we need to
write). It holds the “interrupt vector table,” a list of pointers to
code that is to be called by the hardware when various hardware events
happen. (I think this is “vector” in the sense of “pointer to
something,” rather than the sense of “one-dimensional array:” it is a
table of interrupt-vectors, not a vector of interrupts.) The way the CPU
gets started, after a reset, is first to load the stack pointer with the
address found in the four bytes at the beginning of the interrupt vector
table, and then to jump to the address in the following four bytes.

All of these input sections will be grouped by this linker script into
three output sections: `.text`, `.data`, and `.bss` (although I'm not
actually sure the output names matter). The contents of the `.text`
section will end up in flash memory and the contents of the `.data` and
`.bss` sections will (eventually) end up in RAM. [^1]

If the input files contain other sections not specified in this script
(called “orphaned sections” by the GNU `ld` reference) then my
understanding is that they will be placed in the output file *somewhere*
by the linker anyway. [^2]

<div class="captioned-content">

<div class="caption">

Output sections

</div>

``` ld-script
SECTIONS {
  <<2.1 text output section>>
  <<2.2 data output section>>
  <<2.3 bss output section>>
}
```

</div>

### 2.1 Text output section

The `.text` output section gathers together all the parts of the input
that will end up in flash memory: the vector table, program code, and
read-only data.

<div class="captioned-content">

<div class="caption">

Text output section

</div>

``` ld-script
.text : {
  KEEP(*(.vectors))
  *(.text*)
  *(.rodata*)
} >FLASH
```

</div>

The opening `.text` names the output section. Each line within the curly
braces specifies a set of input sections; namely, those matching the
pattern in the line. For example, the pattern `*(.text*)` matches all
input files (that's the first asterisk) and, within those, all sections
whose name begin with `.text` (that's the second asterisk). [^3]

The `.vectors` section is wrapped in `KEEP` because, as I understand it,
the linker may choose to omit (or “garbage collect”) sections that don't
appear to be referenced by the main sections.

### 2.2 Data output section

The data section is tricky. It contains the initial values of data that
the program may need to change during the course of its execution. Thus,
although this section should be loaded into flash memory, it will need
to be copied to RAM and so all the symbols within it should resolve to
addresses in RAM.

The terminology is as follows. The address of the section at run-time
(in RAM) is called the “virtual memory address” \[VMA\]. The address at
which the section is loaded into memory (that is, in flash memory) is
called the “load memory address” \[LMA\]. Thus, the linker must arrange
for this section to be loaded at the LMA but resolve symbols within it
to point to VMA.

Of course, the data *isn't* at the VMA when the program starts. It's at
the LMA! As a startup action, therefore, the program itself will need to
copy the data from the LMA to the VMA.

Schematically, the linker syntax for output sections is as follows:

``` ld-script
.data [VMA address] : [LMA address] {
   input sections, ...
} >[VMA memory] AT >[LMA memory]
```

The VMA and LMA addresses do not need to be specified explicitly. The
linker puts the section in the next available memory after the last
section in the same region.

However, it will be convenient (when we come to write the code to copy
the data from LMA to VMA) to have this section start and end on a
four-byte boundary because that is the size of a single register in the
CPU. At each point in the linker script, the *location counter*, denoted
by a period, is the address of the current item, relative to the nearest
enclosing scope. The command `ALIGN(4)` returns the value of the
location counter, incremented if necessary to the next location
divisible by four. A typical way to ensure the location counter is
aligned is to write something like

``` ld-script
...
. = ALIGN(4);
...
```

in the script. That assigns the aligned value of the location counter
back to the location counter. However, outside the `.data` section the
location counter refers to the VMA, whereas inside the `.data` section
it will (I think, it's confusing) refer to the *offset* from the
beginning of the session. In neither case will it align the start of the
LMA (which also need to do). The follow approach seems (after much
experimentation!) do to the right thing:

<div class="captioned-content">

<div class="caption">

Data output section

</div>

``` ld-script
.data : ALIGN(4) {
    *(.data)
    *(.data.*)
    . = ALIGN(4);
  } >RAM AT >FLASH
```

</div>

In the `[LMA address]` part of the header line, we assign the LMA to the
aligned location counter (which at this point happens to be the LMA). As
far as I can tell, `ld` will *also* ensure that the VMA address is
similarly aligned, although the manual does not make this clear. At the
end of the section the final align command pads the section, if
necessary so that the section is guaranteed to have a length that is a
multiple of four.

It's necessary to export symbols that refer to the actual locations of
the LMA and VMA (so that the startup code can copy the data from one to
the other). It is common practice to to this by defining, at particular
points in the script, symbols which refer to the location counter at
that point. For example, one might write `__data_start =
.;` to export the beginning of the data section. I don't know why people
do this, since one can also write `__data_start = ADDR(.data);` (and
that is what we will in fact do). My current hypothesis is that it's
historical but I am slightly worried that there's an edge case I have
not understood. (It is definitely true that things are more complicated
than they might appear: see, e.g., the GNU `ld` manual, [section
3.10.5](https://sourceware.org/binutils/docs/ld.html#Location-Counter).)

One last note: I'm not sure why the two data lines aren't a single line,
`*(.data*)`, but this is what the Arm example linker script does so I
have copied it.

### 2.3 BSS output section

The `bss` output section merely reserves space (in RAM) for the
uninitialised data section. (Which I feel is something of a misnomer,
since it *will* be initialised, just to zero.) We use the same alignment
trick as before.

<div class="captioned-content">

<div class="caption">

BSS output section

</div>

``` ld-script
.bss : ALIGN(4) {
  *(.bss)
  *(.bss.*);
  . = ALIGN(4);
} >RAM
```

</div>

## 3. Global symbols

This part of the script defines symbols containing the addresses of the
start and end of various sections.

``` ld-script
/* All the memory from the end of bss to the top of RAM */
__heap_start = .;
__stack_top = ORIGIN(RAM) + LENGTH(RAM);

/* VMA of the .data section */
__data_start = ADDR(.data); 
__data_end   = __data_start + SIZEOF(.data);

/* LMA of the .data section */
__data_load_start = LOADADDR(.data);

/* VMA of the .bss section */
__bss_start = ADDR(.bss);
__bss_end   = __bss_start + SIZEOF(.bss);

/* Entry point (for gdb */
ENTRY(Reset_Handler);
```

The area between `__heap_start` and `stack_top` is all the RAM that is
usable by the program at runtime. (By the way, there are presumably
naming conventions for these things which I am not sure I am
respecting.) Then we need the locations of the `.data` and `.bss`
sections. Finally, it is apparently helpful to define the “entry point”
to the program, because it helps `GDB` (the GNU debugger). At some
point, we wil have to write this code as well and assign the label
`Entry_Handler`. .

# Sources

- I have taken the memory layout from the nRF52833 product
  specification.

- I have referred to both the Arm and Nordic Semiconductor example
  linker scripts (and startup files).

- The [GNU `ld`
  manual](https://sourceware.org/binutils/docs/ld/index.html) explains
  the meanings of the various parts of the linker script.

[^1]: The example linker script provided by Nordic Semiconductor breaks
    out more of the input sections into their own output sections. I
    don't know why one chooses one approach over another.

[^2]: We should probably run `ld` with `--orphan-handling=warn`.

[^3]: GCC emits multiple text sections when the option
    `-ffunction-sections` is used.
